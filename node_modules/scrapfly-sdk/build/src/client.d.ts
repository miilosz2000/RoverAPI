import { ScrapeConfig } from './scrapeconfig.js';
import * as errors from './errors.js';
import { ScrapeResult, AccountData } from './result.js';
import { AxiosResponse } from 'axios';
export declare class ScrapflyClient {
    HOST: string;
    private key;
    private ua;
    constructor(options: {
        key: string;
    });
    /**
     * Raise appropriate error for given response and scrape result
     */
    errResult(response: AxiosResponse, result: ScrapeResult): errors.ScrapflyError;
    /**
     * Turn scrapfly API response to ScrapeResult or raise one of ScrapflyError
     */
    handleResponse(response: AxiosResponse): Promise<ScrapeResult>;
    /**
     * Retrieve Scrapfly account details
     */
    account(): Promise<AccountData>;
    /**
     * Issue a single scrape command from a given scrape configuration
     */
    scrape(config: ScrapeConfig): Promise<ScrapeResult>;
    /**
        Concurrently scrape multiple configs
        This is a async generator call it like this:
  
          const results = [];
          const errors = [];
          for await (const resultOrError of client.concurrentScrape(configs)) {
              if (resultOrError instanceof Error) {
                  errors.push(resultOrError);
              } else {
                  results.push(resultOrError);
              }
          }
        
         @param concurrencyLimit: if not set it will be taken from your account info
       */
    concurrentScrape(configs: ScrapeConfig[], concurrencyLimit?: number): AsyncGenerator<ScrapeResult | Error | undefined, void, undefined>;
}
